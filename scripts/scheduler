#!/bin/bash
# shellcheck shell=bash disable=1091

# Copyright The Red Cyclops Â© 2023
# This program is free software: you can redistribute it and/or modify it under the terms of
# the GNU General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program.
# If not, see <https://www.gnu.org/licenses/>.

# Import libraries
source formatlib
source configlib

info "Attempting to load schedule"

# Get when the program should run again
reloadtime=$(getvalue reload-time)
# Separate it into Hours and Minutes
reloadhour=$(echo "$reloadtime" | cut -d':' -f1)
reloadmin=$(echo "$reloadtime" | cut -d':' -f2)
# Validate the time
#if [[ "$reloadhour" -gt 24 ]]; then
#    reloadhour=23
#    reloadmin=59
#    warn "Hour field on reload time was over 23 setting to 23 and minutes to 59"
#fi
#if [[ "$reloadmin" -gt 59 ]]; then
#    reloadmin=59
#    warn "Minute field on reload time was over 59 setting to 59"
#fi

# Write start of crontab to a temporary file
info "Writting crontab"
echo "
#User Cron tab
# min    hour    day    month    weekday    command
  @reboot    $MUSICBOX_BIN_DIR/load | tee $MUSICBOX_LOG_DIR/$(date +%Y-%m-%d).log
  $reloadmin      $reloadhour       *      *        1-5        $MUSICBOX_BIN_DIR/load | tee $MUSICBOX_LOG_DIR/$(date +%Y-%m-%d)/.log"\
   > "$MUSICBOX_CACHE_DIR/newcrontab.txt"

# Set the schedule file
schedule="$MUSICBOX_CACHE_DIR/schedule"
# Check that the schedule file exists
[ -f "$schedule" ] || critical "Schedule file wasn't downloaded"
# Create functions
getmode(){
    awk -v FPAT='[^[:space:]]+' '{print $1}' "$schedule"  | exec $(printf 'sed %s!d' "${1}")
}
gettime(){
    awk -v FPAT='[^[:space:]]+' '{print $2}' "$schedule"  | exec $(printf 'sed %s!d' "${1}")
}
getsong(){
    song=$(awk -v FPAT='[^[:space:]]+' '{print $3}' "$schedule" | exec $(printf 'sed %s!d' "${1}"))
    if [[ "$song" == "random" ]]; then
        for song in "$MUSICBOX_CACHE_DIR"/songs/*; do
            if ! grep -Fxq "$song" "$MUSICBOX_CACHE_DIR"/scheduledsongs; then
                break
            fi
        done
        echo "$song" | tee "$MUSICBOX_CACHE_DIR"/scheduledsongs
    else
    echo "$MUSICBOX_CACHE_DIR/extra-songs/${song:?}" || error "Specified song not found or not parsed properly!"
    fi
}
# Parse schedule
line=1
critical "Failure Point"
critical "Outputing test $(wc -l "$schedule" | cut -d' ' -f1)"
while [[ $line -le $(wc -l "$schedule" | cut -d' ' -f1) ]]; do
    case $(getmode $line) in
        start) 
            date "+%M   %H  *   *   *   cvlc --no-video $(getsong $line)" --date="$(gettime $line)" >> "$MUSICBOX_CACHE_DIR/newcrontab.txt";;
        stop)
            etime="$(date '+%s' --date="$(gettime $line)")"
            song=$(getsong $line)
            songduration="$(mp3info -p "%S" "$song")"
            fetime=$((etime-songduration))
            date "+%M   %H  *   *   *   cvlc --no-video $song" --date="@$fetime" >> "$MUSICBOX_CACHE_DIR/newcrontab.txt";;
        *)
        warn "Misformated line found in schedule, proceeding...";;
    esac
    ((line++))
done

# Schedule Cleanup
date "+%M   %H  *   *   *   $MUSICBOX_BIN_DIR/cleanup" --date="$(getvalue cleanup-time)" >> "$MUSICBOX_CACHE_DIR/newcrontab.txt"

# Add newline at the end of crontab
printf '\n' >> "$MUSICBOX_CACHE_DIR/newcrontab.txt"

# Set newcrontab.txt to be the crontab
crontab "$MUSICBOX_CACHE_DIR/newcrontab.txt"
cronstatus=$?
# Remove the temporary cron file
if [[ $cronstatus = 0 ]]; then
	rm "$MUSICBOX_CACHE_DIR/newcrontab.txt"
else
	critical "Failed to set crontab"
fi
