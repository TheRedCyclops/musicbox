#!/bin/bash
# shellcheck shell=bash disable=1091
# Import libraries
. formatlib
. configlib
# Get when the program should run again
getvalue reload-time
# Separate it into Hours and Minutes
# Validate the time
if [ "$reloadhour" -gt 24 ]; then
    reloadhour=23
    reloadmin=59
fi
if [ "$reloadhour" -gt 59 ]; then
    reloadmin=59
fi

# Write start of crontab to a temporary file
info "Writting crontab"
echo "
#User Cron tab
# min    hour    day    month    weekday    command
  $reloadmin      $reloadhour       *      *        1-5        load | tee $MUSICBOX_LOG_DIR/$(date +%Y-%m-%d)
" > "$MUSICBOX_CACHE_DIR/newcrontab.txt"

# Set the schedule file
schedule="$MUSICBOX_CACHE_DIR/schedule"
# Create functions to recognise start and end written in file
getstarttime(){
# Pass the entire line outputs start time in HH:MM format
    printf "%s" "$1" | sed  -E -e 's/\s+(short|\*|[0-9]{1,2}:[0-9]{1,2})$//m' 
}
getstoptime(){
# Pass the entire line outputs stop time in HH:MM format
    printf "%s" "$1" | sed  -E -e 's/^([0-9]{1,2}:[0-9]{1,2}|\*)\s+//m' 
}
# Parse schedule
for i in read -n $schedule; do
    starttime=$(getstarttime "$(sed "${i}q;d" "$schedule")")
    stoptime=$(getstoptime "$(sed "${i}q;d" "$schedule")")
# if only start time is set start at the start time
    if [ "$stoptime" = "*" ]; then 
        start="$(date "+0   %M    %H    *   *   *" "$starttime")"
        printf "%s  music-player --onesong | tee $MUSICBOX_LOG_DIR/$(date +%Y-%m-%d)\n" "$start" >> "$MUSICBOX_CACHE_DIR/newcrontab.txt"
    fi
# if the stop time is set to "short" then play the short.mp3 audio
    if [ "$stoptime" = "*" ]; then 
        start="$(date "+0   %M    %H    *   *   *" "$starttime")"
        printf "%s  music-player --short | tee $MUSICBOX_LOG_DIR/$(date +%Y-%m-%d)\n" "$start" >> "$MUSICBOX_CACHE_DIR/newcrontab.txt"
    fi
# if only stop time is set get what the latest unplayed song will be and sustract the length from the time to stop
    virtualplayedsonglist="$MUSICBOX_CACHE_DIR/virtual-played-song-list"
    j=0
        for j in read -n $schedule; do
         if [ "$j" = "$i" ]; then
         break;
         elif echo "$j" | grep -q "\*"; then
            while [ -z "$selectedsong" ]; do
                i=1
                # Loop through the songs until the latest one that hasn't been played is reached
                # shellcheck disable=2012
                latestsong=$(ls "$MUSICBOX_CACHE_DIR/music/" -tw 1 | sed "${i}q;d")
                if ! grep -q "$latestsong" "$MUSICBOX_CACHE_DIR/played-songs"; then
                selectedsong=$latestsong
                else
                i=$((i+1))
                fi
                # Check for the case of no songs
                if [ "$(ls "$MUSICBOX_CACHE_DIR/music/*")" = '' ]; then
                error "No songs found when searching for the latest!"
                break;
                fi
            done
            echo "$latestsong" >> "$virtualplayedsonglist"
         else
            # In this case the song is going to be played for a predetermined amount of time
            #TODO: Actualy count the songs
            getstarttime "$j"
            getstoptime "$j"
            
         fi
        if [ -z "$starttime" ]; then
            error "The start time wasn't recognised for song $i"
        fi

        done
    
    
# If both are set just pass the stop time to the music player and start at starttime
    if [ "$stoptime" != "*" ] && [ "$starttime" != "*" ]; then 
        start="$(date "+%M    %H" "$starttime")"
        printf "%s\n" "$start"
    fi
done
# Schedule Cleanup

date "+%M   %H" "$(getvalue cleanuptime)" 